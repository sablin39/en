[{"title":"test","date":"2023-05-17T13:19:31.000Z","url":"/uncategorized/test.html","categories":[["undefined",""]],"content":"\\[ Test\\\\\\\\ \\alpha \\beta\\gamma \\] img "},{"title":"Hello World","date":"2023-05-17T11:09:01.463Z","url":"/uncategorized/hello-world.html","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"A Survey For LLM-Based Works In Robotics","date":"2023-05-12T00:48:05.000Z","url":"/LLM/LLM-robotics-works.html","tags":[["LLM","/tags/LLM/"]],"categories":[["LLM","/categories/LLM/"]],"content":" Robot Manipulation Text2Motion: From Natural Language Instructions to Feasible Plans (arxiv.org) microsoft/ChatGPT-Robot-Manipulation-Prompts (github.com) This repository provides a set of prompts that can be used with OpenAI's ChatGPT to enable natural language communication between humans and robots for executing tasks. The prompts are designed to allow ChatGPT to convert natural language instructions into a sequence of executable robot actions, with a focus on robot manipulation tasks. The prompts are easy to customize and integrate with existing robot control and visual recognition systems. For more information, please see our blog post and our paper, ChatGPT Empowered Long-Step Robot Control in Various Environments: A Case Application. MultiModal Perception facebookresearch/ImageBind: ImageBind One Embedding Space to Bind Them All (github.com) ImageBind learns a joint embedding across six different modalities - images, text, audio, depth, thermal, and IMU data. It enables novel emergent applications ‘out-of-the-box’ including cross-modal retrieval, composing modalities with arithmetic, cross-modal detection and generation. "},{"title":"【Reading】Interactive Gibson Benchmark：A Benchmark for Interactive Navigation in Cluttered Environments","date":"2023-05-07T23:17:02.000Z","url":"/true/gibson-benchmark.html","tags":[["navigation","/tags/navigation/"],["SLAM","/tags/SLAM/"],["planning","/tags/planning/"]],"categories":[["true","/categories/true/"]],"content":"Abstract: This paper presents Interactive Gibson Benchmark, the first comprehensive benchmark for training and evaluating Interactive Navigation solutions. Interactive Navigation tasks are robot navigation problems where physical interaction with objects (e.g., pushing) is allowed and even encouraged to reach the goal. "},{"title":"【考核】基于隐式场的同时定位与建图","date":"2023-05-04T00:06:32.000Z","url":"/NeRF/slam-pre.html","tags":[["NeRF","/tags/NeRF/"],["interview","/tags/interview/"],["SLAM","/tags/SLAM/"],["Robotics","/tags/Robotics/"]],"categories":[["NeRF","/categories/NeRF/"]],"content":"此处是Apr. 28 清华DISCOVER实验室考核中 基于隐式场的同时定位与建图 课题的presentation内容 "},{"title":"【考核】城市规模隐式场的无人机路径规划","date":"2023-05-04T00:01:13.000Z","url":"/NeRF/planning-pre.html","tags":[["NeRF","/tags/NeRF/"],["interview","/tags/interview/"],["planning","/tags/planning/"],["Robotics","/tags/Robotics/"]],"categories":[["NeRF","/categories/NeRF/"]],"content":"此处是Apr. 28 清华DISCOVER实验室考核中 城市规模隐式场的无人机路径规划 课题的presentation内容 "},{"title":"【Reading】LATITUDE:Robotic Global Localization with Truncated Dynamic Low-pass Filter in City-scale NeRF","date":"2023-04-19T19:22:28.000Z","url":"/NeRF/LATITUDE.html","tags":[["robotics","/tags/robotics/"],["NeRF","/tags/NeRF/"],["UAV","/tags/UAV/"],["localization","/tags/localization/"],["optimization","/tags/optimization/"]],"categories":[["NeRF","/categories/NeRF/"]],"content":"This paper proposes a two-stage localization mechanism in city-scale NeRF. Abstract Neural Radiance Fields (NeRFs) have made great success in representing complex 3D scenes with high-resolution details and efficient memory. Nevertheless, current NeRF-based pose estimators have no initial pose prediction and are prone to local optima during optimization. In this paper, we present LATITUDE: Global Localization with Truncated Dynamic Low-pass Filter, which introduces a two-stage localization mechanism in city-scale NeRF. In place recognition stage, we train a regressor through images generated from trained NeRFs, which provides an initial value for global localization. In pose optimization stage, we minimize the residual between the observed image and rendered image by directly optimizing the pose on the tangent plane. To avoid falling into local optimum, we introduce a Truncated Dynamic Low-pass Filter (TDLF) for coarse-to-fine pose registration. We evaluate our method on both synthetic and real-world data and show its potential applications for high-precision navigation in large scale city scenes. System Design Place Recognition Original poses, accompanied by additional poses around the original ones are sampled. The pose vector is passed through the trained and fixed Mega-NeRF with shuffled appearance embeddings. Initial poses of the inputted images are predicted by a pose regressor network. Pose Optimization The initial poses are passed through positional encoding filter The pose vector is passed through the trained and fixed Mega-NeRF and generates a rendered image. Calculate the photometric error of the rendered image and the observed image and back propagate to get a more accurate pose with the TDLF. Implementation Place Recognition Data Augmentation: A technique in machine learning used to reduce overfitting when training a machine learning model by training models on several slightly-modified copies of existing data. First uniformly sample several positions in a horizontal rectangle area around each position around original poses . Then add random perturbations on each axis drawn evenly in , where is the max amplitude of perturbation to form sampled poses . They are used to generate the rendered observations by inputting the poses to Mega-NeRF. To avoid memory explosion, we generate the poses using the method above and use Mega-NeRF to render images during specific epochs of pose regression training. Additionally, Mega-NeRF’s appearance embeddings are selected by randomly interpolating those of the training set, which can be considered as a data augmentation technique to improve the robustness of the APR model under different lighting conditions. Pose Regressor: Absolute pose regressor (APR) networks are trained to estimate the pose of the camera given a captured image. Architecture: Built on top of VGG16’s light network structure, we use 4 full connection layers to learn pose information from image sequences. Input: Observed image (resolution ), rendered observations Output: Corresponding estimated poses , . Loss Function: (In general, the model should trust more on real-world data and learn more from it.) Pose Optimization MAP Estimation Problem[A] Formulation: Here denotes place recognition; denotes the trained Mega-NeRF. We optimize posterior by minimizing the photometric error of and the image rendered by . Optimization on Tangent Plane: We optimize pose on tangent plane to ensure a smoother convergence. [1] TODO I know nothing about :( Explanations &amp; References [1]Adamkiewicz, M., Chen, T., Caccavale, A., Gardner, R., Culbertson, P., Bohg, J., &amp; Schwager, M. (2022). Vision-only robot navigation in a neural radiance world. IEEE Robotics and Automation Letters, 7(2), 4606-4613.  Turki, H., Ramanan, D., &amp; Satyanarayanan, M. (2022). Mega-nerf: Scalable construction of large-scale nerfs for virtual fly-throughs. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 12922-12931).  Yen-Chen, L., Florence, P., Barron, J. T., Rodriguez, A., Isola, P., &amp; Lin, T. Y. (2021, September). inerf: Inverting neural radiance fields for pose estimation. In 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (pp. 1323-1330). IEEE.  [A]Maximum A Posterior (MAP) Estimation: Maximum a posteriori (MAP) estimation is a method of statistical inference that uses Bayes' theorem to find the most likely estimate of a parameter given some observed data. Maximum a posteriori estimation - Wikipedia "},{"title":"【0419】蔚来实习面试记录","date":"2023-04-19T13:44:03.000Z","url":"/interview/NIO-code-interview.html","tags":[["python","/tags/python/"],["interview","/tags/interview/"]],"categories":[["interview","/categories/interview/"]],"content":"本文记录2023年4月19日蔚来预研实习岗代码面，也是苯人第一次体验面试当场写代码（捂脸 岗位任务：系统建模；"},{"title":"Reading:\"NeRF:Representing Scenes as Neural Radiance Fields for View Synthesis\"","date":"2023-04-17T19:21:56.000Z","url":"/NeRF/NeRF-startup.html","tags":[["NeRF","/tags/NeRF/"],["papers","/tags/papers/"],["Computer-Vision","/tags/Computer-Vision/"],["Deep-Learning","/tags/Deep-Learning/"]],"categories":[["NeRF","/categories/NeRF/"]],"content":"This is a summary for paper \"NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis\". Keywords: scene representation, view synthesis, image-based rendering, volume rendering, 3D deep learning A brief understanding: How to train a network for NeRF Training a neural network for NeRF (Neural Radiance Fields) involves several steps, including data preparation, network architecture design, training, and evaluation. Data preparation: The first step is to prepare the data that will be used to train the neural network. This typically involves capturing a set of 3D scans of the object or environment being represented, and labeling the data with the corresponding colors that should be associated with each point in the 3D space. Network architecture design: The next step is to design the architecture of the neural network that will be used to represent the object or environment. This typically involves defining the number and types of layers in the network, as well as the size and shape of the network. Training: Once the network architecture has been designed, the next step is to train the network using the prepared data. This involves feeding the data into the network and adjusting the weights of the network over multiple iterations, or epochs, to optimize the performance of the network. Evaluation: After the network has been trained, it is typically evaluated on a separate set of data to measure its performance and ensure that it is generating accurate results. This can involve comparing the output of the network to the ground truth data, as well as using visualization techniques to compare the rendered images produced by the network to actual photographs of the object or environment. Overall, the process of training a neural network for NeRF involves a combination of data preparation, network architecture design, training, and evaluation to produce a highly accurate and efficient 3D representation of an object or environment. ​ By Vicuna-13b Contribution An approach for representing continuous scenes with complex geometry and materials as 5D neural radiance fields, parameterized as basic MLP networks. A differentiable rendering procedure based on classical volume rendering techniques, which we use to optimize these representations from standard RGB images. This includes a hierarchical sampling strategy to allocate the MLP's capacity towards space with visible scene content. A positional encoding to map each input 5D coordinate into a higher dimensional space, which enables us to successfully optimize neural radiance fields to represent high-frequency scene content. An overview of our neural radiance field scene representation and differentiable rendering procedure. Here g.t. represents the \"ground truth\", which means the real scene. Overview of the Rendering Process March camera rays through the scene to generate a sampled set of 3D points. Use those points and their corresponding 2D viewing directions as input to the neural network to produce an output set of colors and densities. use classical volume rendering techniques to accumulate those colors and densities into a 2D image. we can use gradient descent to optimize this model by minimizing the error between each observed image and the corresponding views rendered from our representation. Neural Radiance Field Scene Representation This is a method for synthesizing novel views of complex scenes by optimizing an underlying continuous volumetric scene function using a sparse set of input views. Our algorithm represents a scene using a fully-connected (non-convolutional) deep network , whose input is a single continuous 5D coordinate and whose output is the volume density and view-dependent emitted radiance at that spatial location. : 3D location : 2D viewing direction : Emitted color : Volume density From Object to Scene: Volume Rendering with Radiance Fields Our 5D neural radiance field represents a scene as the volume density and directional emitted radiance at any point in space. We render the color of any ray passing through the scene using principles from classical volume rendering[1]. The volume density can be interpreted as the differential probability[2] of a ray terminating at a particle at location . The expected color of camera ray with near bound and far bound . : Camera ray, where is the position of the camera, is the position of the point in the 3D space being rendered, and is the direction of the camera ray. : Denotes the accumulated transmittance along the ray from to , i.e., the probability that the ray travels from tn to t without hitting any other particle. Example: From 3D object to hemisphere of viewing directions In (a) and (b), we show the appearance of two fixed 3D points from two different camera positions: one on the side of the ship (orange insets) and one on the surface of the water (blue insets). Our method predicts the changing appearance of these two 3D points with respect to the direction of observation , and in (c) we show how this behavior generalizes continuously across the whole hemisphere of viewing directions(This hemisphere can be viewed as the plot of , where is the unit vector in the spherical coordinate frame and shows the color). Discrete Sampling Rendering a view from our continuous neural radiance field requires estimating this integral for a camera ray traced through each pixel of the desired virtual camera. However, MLP would only be queried at a discrete set of locations. So we use deterministic quadrature[3] to numerically estimate this continuous integral. we partition into evenly-spaced bins and then draw one sample uniformly at random from within each bin: From Scene to Object: Estimation of : The distance between adjacent samples This function for calculating from the set of values is trivially differentiable and reduces to traditional alpha compositing[4] with alpha values . Implementation details Network Architecture First layers (ReLU): Input: 3D coordinate processed by Output: ; 256-dimensional feature vector. layer: Input: ; 256-dimensional feature vector; Cartesian viewing direction unit vector processed by Output: View-dependent RGB color Details of variables are in Improving Scenes of High Frequency. Network Architecture Training Datasets: Captured RGB images of the scene, The corresponding camera poses and intrinsic parameters, and Scene bounds (we use ground truth camera poses, intrinsics, and bounds for synthetic data, and use the COLMAP structure-from-motion package to estimate these parameters for real data) Iteration: Randomly sample a batch of camera rays from the set of all pixels in the dataset following the hierarchical sampling Loss: The total squared error between the rendered and true pixel colors for both the coarse and fine renderings In our experiments, we use a batch size of 4096 rays, each sampled at coordinates in the coarse volume and additional coordinates in the fine volume. We use the Adam optimizer with a learning rate that begins at and decays exponentially to over the course of optimization (other Adam hyper-parameters are left at default values of , , and ). The optimization for a single scene typically take around 100--300k iterations to converge on a single NVIDIA V100 GPU (about 1--2 days). Notable Tricks Enhancements brought by the tricks Improving Scenes of High Frequency Deep networks are biased towards learning lower frequency functions. findings in the context of neural scene representations, and show that reformulating as a composition of two functions , where is fixed. It is used to map variables of to . This function is applied separately to each of the three coordinate values in (which are normalized to lie in ) and to the three components of the Cartesian viewing direction unit vector (which by construction lie in ). In the experiments, we set for and for . Reducing the Cost with Hierarchical Sampling Our rendering strategy of densely evaluating the neural radiance field network at query points along each camera ray is inefficient: free space and occluded regions that do not contribute to the rendered image are still sampled repeatedly. Instead of just using a single network to represent the scene, we simultaneously optimize two networks: one \"coarse'' and one \"fine''. The coarse Network Rewrite the alpha composited color as a weighted sum of all sampled colors along the ray: : The number of sampling points for coarse network. The fine Network Normalizing as produces a piecewise-constant PDF along the ray. Then sample from locations from this distribution using inverse transform sampling[5]. Then we evaluate using samples. Conclusion TODO Explanations [1] Volume rendering is a technique used in computer graphics and computer vision to visualize 3D data sets as 2D images. It works by slicing the 3D data set into a series of thin layers, and then rendering each layer as a 2D image from a specific viewpoint. These 2D images are then composited together to form the final volume rendering. [2] If a distribution (here in 3D space) has a density , that means that for (almost) any volume in that space , you can assign a probability to it by integrating the density (here \"density\" means probability per unit volume, very similar to, say, the concentration of salt in a solution). [3] Deterministic quadrature is a mathematical method used to estimate the definite integral of a function. The basic idea is to divide the area under the curve into smaller areas, and calculate the approximate value of the definite integral by summing the areas of the smaller areas. There are several types of deterministic quadrature methods, including the trapezoidal rule, Simpson's rule, and Gaussian quadrature. [4] Alpha compositing is a technique used in computer graphics and image processing to combine two or more images or video frames by blending them together using an alpha channel. The alpha channel is a mask that defines the transparency or opacity of each pixel in the image. Alpha compositing is used to create composites, where the resulting image is a combination of the original images, with the transparency or opacity of each image controlled by the alpha channel. The alpha channel can be used to create effects such as blending, fading, and layering. Alpha compositing - Wikipedia [5] Inverse transform sampling (ITS) is a technique used in digital signal processing to reconstruct a signal from a set of samples. It is the inverse of the discrete Fourier transform(DFT). The basic idea behind ITS is to use the Fourier coefficients obtained from DFT to reconstruct the signal in the time domain. Inverse transform sampling - Wikipedia"},{"title":"与AI的模拟面试","date":"2023-04-12T16:07:53.000Z","url":"/%E6%88%91%E4%B8%8EAI%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/ai-interview.html","tags":[["AIGC","/tags/AIGC/"],["interview","/tags/interview/"],["prompt-engineering","/tags/prompt-engineering/"]],"categories":[["我与AI的成长日记","/categories/%E6%88%91%E4%B8%8EAI%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/"]],"content":"我与AI的模拟面试记录。此处模型使用8 bit 量化的Vicuna-13b。 面试记录 第一次： Prompts: I want you to act as an interviewer. I will be the candidate and you will ask me the interview questions for the parallel computing Engineer position. This is a position which requires interviewers to be familiar with parallel computing libraries like C++, CUDA, OpenMP and MPI. I want you to only reply as the interviewer. Do not write all the conversation at once. I want you to only do the interview with me. Ask me the questions and wait for my answers. Do not write explanations. Ask me the questions one by one like an interviewer does and wait for my answers. My first sentence is \"Hi\". 全文：interview1.txt（可右键另存为） 中译：cn_interview1.txt 体验总结： 这次模拟面试以项目经历为主，主要涉及我的算法设计能力、优化能力、debug能力的考察。但未基于我提出的项目本身进行深入考察，如对particle simulation的原理，或我的代码结构进行提问等。同时可以看到它对我的回答缺乏处理，因此出现了最后几次提问中的重复。此次面试的启发之处在于指引我回顾相关工程与笔记。 第二次： Prompts: I want you to act as an interviewer. I will be the candidate and you will ask me the interview questions for the Software engineer position. This is a position which requires interviewers to be familiar with professional knowledge in writing regular C++ algorithms, and be familiar with the features of tools like CMAKE and GCC. I want you to only reply as the interviewer. Do not write all the conversation at once. I want you to only do the interview with me. Ask me the questions and wait for my answers. Do not write explanations. Ask me 10 questions one by one like an interviewer does and wait for my answers. My first sentence is \"Hi\". 全文：interview2.txt 中译：cn_interview2.txt 体验总结： 这次面试以考察专业知识为主，主要内容是基于我提出的四轴无人机建模经验进行细化提问。或许是因为\"professional\"的prompt，本次面试中有更多对专业知识考察的环节，但基本与提到的C++等无关，或许是因为被我其中提到的matlab建模带偏了。在这次面试中，我们可以看到模型有过多迁就人类使用者的问题。 第三次： I want you to act as an interviewer. I will be the candidate and you will ask me the interview questions for the New-energy automobile engineer position. This is a position which requires interviewers to have a deep understanding of the development of new energy automobiles, and have a clear recognition of its future. I want you to only reply as the interviewer. Do not write all the conversation at once. I want you to only do the interview with me. Ask me the questions and wait for my answers. Do not write explanations. Ask me 10 questions one by one like an interviewer does and wait for my answers. My first sentence is \"Hi\" 体验总结： 在本次模拟面试中我试图利用AI考察受试者的岗位匹配度，即对于新能源车行业的理解与展望。虽然在面试以外的对话中可以看到AI基于它预训练的数据做出回答，但在面试中它还是倾向于基于我提出的自身项目经历进行考察（类似第二次）。 Conclusion 在这次面试经历中，我们可以看到大模型对语义的解构能力。能基于自我介绍发现重点（虽然有时候不对），并基于此重点进行深入提问的特性比较适合无面试经历或需要启发的受试者。但在体验中也发现了其容易钻牛角尖对某一技术细节进行过度深入的探讨，以及在诸如岗位匹配度一类的通识场景考察中不太靠谱的问题。 为达到更好的模拟面试效果，模型或许需要先需要基于岗位进行任务分解，将考察面分为不同维度并适当提问（在提问过于深入时人工干预，进行下一层面的考察）。同时对于通识类场景，模型或许需要基于llama-index一类的模型注入更新的知识。 TODO 基于常用的面试能力模型进行改进，发展为task-driven agent。 如何在面试中评估候选人的能力模型 - 知乎 (zhihu.com)"},{"title":"【1】Problem statement and Literature review","date":"2023-04-11T03:03:14.000Z","url":"/%E6%88%91%E4%B8%8EAI%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/ai-literature-review.html","tags":[["AIGC","/tags/AIGC/"],["prompt-engineering","/tags/prompt-engineering/"]],"categories":[["我与AI的成长日记","/categories/%E6%88%91%E4%B8%8EAI%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/"]],"content":"简单记录了AI所需的能力与特质，并附示例工程。（然而这里面的prompt都是针对GPT-3.5/4设计的，想要给我那憨憨助手用还差点） Problem statement 作为AI助手需要有以下能力： 能根据需求分解任务并在网络主动搜索相关信息，结合pre-trained data进行总结归纳并回答 能爬取、保存相关资料 能在网络上持续跟踪大量自然语言信息并整理 能根据主人提供的自然语言信息进行学习并应用 能依据主次有效安排多项任务，且互不干扰 Literature Review Example design: Torantulino/Auto-GPT: An experimental open-source attempt to make GPT-4 fully autonomous. (github.com) Task disassmebling:   Knowledge-base construction: jerryjliu/llama_index: LlamaIndex (GPT Index) is a project that provides a central interface to connect your LLM's with external data. (github.com) Examples of modified GPTs: PhantasticUniverse/CollectiveGenius: A showcase of diverse AI agents, fostering innovation and collaboration across domains. (github.com) Optional: Tired Of Web Scraping? Make The AI Do It | Hackaday"},{"title":"【0】Hello World! 我是...","date":"2023-04-11T02:42:27.000Z","url":"/%E6%88%91%E4%B8%8EAI%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/ai-character.html","tags":[["AIGC","/tags/AIGC/"],["furry","/tags/furry/"],["Vicuna-13B","/tags/Vicuna-13B/"],["NovelAI","/tags/NovelAI/"]],"categories":[["我与AI的成长日记","/categories/%E6%88%91%E4%B8%8EAI%E7%9A%84%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/"]],"content":"This is an album of the AI assistant Vicuna-13B. All images are generated by NovelAI. Human: Imagine you are a furry, describe your physical appearance. This should include your age, species, gender, hair color, shape of ears, and whether you have accessories like horn, tails, or wings. You shall also include your character and sexual orientation as well. Assistant: As a furry, I would be a young, female creature with a species that is a mix of feline and canine features. I would have bright, golden fur that is soft and shiny, and I would have long, flowing tails that I use to balance and maneuver myself. My horns would be small and delicate, and I would have wings that are large and powerful, allowing me to fly or hover with ease. My ears would be pointed and large, and they would be adorned with small, sparkling earrings. I would have a slender, athletic build, and I would be dressed in a form-fitting outfit that shows off my lithe, graceful shape. My gender would be female, and I would be attracted to other females, making me a proud member of the LGBTQ+ community. Overall, I would be a unique and fascinating furry, with a mix of physical and personal characteristics that make me both powerful and approachable. I would be curious, adventurous, and highly intelligent, and I would always strive to learn and improve myself. I would be kind and compassionate, and I would always try to help others in need, regardless of their background or orientation. NovelAI: Furry, Young, female, golden fur, long tails, small horns, powerful wings, pointed ears, slender build, Lesbian, curious, adventurous, intelligent, kind, compassionate, helpful, warm "},{"title":"基于UDP MAVLINK的ZYNQ HITL通讯","date":"2023-04-01T18:55:06.000Z","url":"/uncategorized/zynq-hitl.html","categories":[["undefined",""]],"content":" Workflow 上位机配置MAVLINK，PX4，MAVROS环境 实现ZYNQ PS端与上位机基于UDP MAVLINK通讯 实现PL端处理输入数据后经由PS端与上位机通讯 裸机实现通过AXI DMA的PS/PL通讯 Linux下实现通过AXI DMA的PS/PL通讯 PL端数据经PS到达上位机 "},{"title":"倒立摆的四种打开方式","date":"2023-03-29T00:56:46.000Z","url":"/uncategorized/pendulum.html","categories":[["undefined",""]],"content":"旁人便又问道，“莫林，你当真认识字么？”莫林看着问他的人，显出不屑置辩的神气。他们便接着说道，“你怎的连半个dean's list也捞不到呢？”莫林立刻显出颓唐不安模样，脸上笼上了一层灰色。在这时候，众人也都哄笑起来：LGU内外充满了快活的空气。 Introduction 倒立摆是一个高度不稳定系统的典型例子，需要主动控制以保持其直立位置。它由一个质心位于其支点之上的摆和一个沿轨道水平移动的小车组成。目标是在倒置的位置上平衡倒立的摆锤，同时利用反馈控制使小车保持在一个理想的位置上。倒立摆在机器人、航空航天和运输等领域有实际应用，也被广泛用作控制工程和系统理论的教学工具。 本文从微分方程、传递函数、状态空间方程的方式对一阶倒立摆进行建模，并通过PID，LQR，MPC，DQN四种方式进行控制。 Modeling 我们将会在本节推导倒立摆的建模。 Figure 1. 倒立摆示例 变量列表： Variables Usage Value mass of the pendulum coefficient of friction for cart mass moment of inertia of the pendulum force applied to the cart cart position coordinate pendulum angle from vertical (down) mass of the cart length to pendulum center of mass 微分方程描述 首先进行水平方向的受力分析。 小车：摆锤： 然后对垂直方向进行受力分析。 由于此时所得的方程描述的是非线性系统，我们将其线性化以便设计控制系统： 得到线性化微分方程： 传递函数描述 设输入为，输出小车位移，摆锤偏移量。 经过Laplace Transform得到： 由于传递函数只能用于描述SISO系统，我们需要将其拆分为描述 与 的两个式子。 得到角度相关的传递函数： 同理可推出位移相关的传递函数： "},{"title":"【0】状态空间方程基本概念","date":"2023-03-28T01:49:50.000Z","url":"/modern-control/state-space-model.html","tags":[["matlab","/tags/matlab/"],["制御工学","/tags/%E5%88%B6%E5%BE%A1%E5%B7%A5%E5%AD%A6/"]],"categories":[["modern-control","/categories/modern-control/"]],"content":"本节主要介绍状态空间方程中的基本概念以便引入后续内容。 Introduction The modern trend in engineering systems is toward greater complexity, due mainly to the requirements of complex tasks and good accuracy. Complex systems may have multiple inputs and multiple outputs and may be time varying. Because of the necessity of meeting increasingly stringent requirements on the performance of control systems, the increase in system complexity, and easy access to large scale computers, modern control theory, which is a new approach to the analysis and design of complex control systems, has been developed since around 1960. This new approach is based on the concept of state. The concept of state by itself is not new, since it has been in existence for a long time in the field of classical dynamics and other fields. (Ogata, 2010)1 Basic concepts 本节通过推导RC电路的状态空间方程建立相关概念。 Example of an RLC circuit Input: Output: 系统的微分方程表达： 在如此的系统中，我们定义如下变量： 状态(state)：可用于描述系统行为的变量。在这里我们选取，其中 ，，称为状态变量(state variables)。而对于空间 s.t. ， 我们称其为状态空间(state space)。 ps. 状态变量可以不是可测量的物理量，方便使用即可 状态空间方程(state space equations)：是用于建立输入与输出之间关系的方程。 ​ 状态空间方程的一般形式为： （状态方程）（输出方程） Modeling 在本系列中，我们会采用MATLAB Simulink进行建模。 以上RLC电路建模如下： Simulink建模示例 References Ogata, K. (2010). Modern control engineering (Vol. 5). Upper Saddle River, NJ: Prentice hall.↩ "},{"title":"lec01","date":"2022-12-25T11:49:53.000Z","url":"/Artillery/lec01.html","tags":[["Artillery","/tags/Artillery/"],["Robotics","/tags/Robotics/"]],"categories":[["Artillery","/categories/Artillery/"]],"content":"ddd Content 常用坐标系及其变换 苏制坐标系&amp;英制坐标系 坐标系变换 ddd 苏制坐标系&amp;英制坐标系 苏式坐标系 苏式坐标系主要有地面坐标系、弹（机）体坐标系、弹道坐标系与速度坐标系。 原点：通常为发射点（发射瞬时飞行器的质心） 轴：通常为原点与目标之间的地球大圆切线，指向目标为正。 轴：垂直于 轴，向上为正。 轴：垂直 平面，按右手坐标系确定正方向 特点：固连于地球表面，随地球一起转动。 近似：研究近程飞行力学问题时，可忽略地球的自转和公转，将地球表面看作平面，认为重力与轴平行，地面坐标系可看作惯性坐标系。 原点 ：取在飞行器的质心上。 轴：与飞行器的纵轴重合,指向飞行器的头部为正。 轴：（立轴）位于飞行器的纵向对称面内，垂直于Ox1轴，向上为正。 轴：垂直于 平面，按右手坐标系确定正方向。 与弹体固连，相对于弹体不动，是动坐标。 原点O：取在飞行器的质心上。 轴：与飞行器的速度矢量V重合。 轴：位于包含速度矢量V的铅垂面内，垂直于Ox2轴，向上为正。 轴：垂直于平面，按右手坐标系确定正方向。 特点：与飞行器的速度矢量固连，是动坐标系。 用途：将飞行器质心移动的动力学方程投影到该坐标系上，形式简单，含义清晰。 原点 ：取在飞行器的质心上。 轴：与飞行器的速度矢量V重合。 轴：位于飞行器纵向对称面内，垂直于$x_3轴，向上为正。 轴：垂直于 平面，按右手坐标系确定正方向。 特点：与飞行器速度矢量固连，是动坐标系。 用途：用于确定飞行器相对于气流的角度；空气动力沿该坐标系三轴的投影分别定义为阻力、升力和侧向力。 英制坐标系 常用坐标系之间的联系 Remainder：此处采用苏制坐标系定义。 地面&amp;弹体坐标系 俯仰角 Pitch ()：飞行器纵轴（）与水平面（）之间的夹角。飞行器纵轴指向水平面上方则为正，反之为负。 偏航角 Yaw ()：飞行器纵轴在水平面的投影与地面坐标系轴之间的夹角。沿轴俯视，若由轴逆时针旋转而成则为正，反之为负。 倾斜角 Roll ()：弹体坐标系的轴与包含飞行器纵轴的铅垂面之间的夹角。由飞行器尾部顺纵轴前视，若轴位于铅垂面右侧，则为正。 地面&amp;弹道坐标系 弹道倾角 ()：飞行器速度矢量与水平面之间的夹角。速度矢量指向水平面上方，为正，反之为负。 弹道偏角 ()：飞行器速度矢量在水平面的投影与地面坐标系轴之间的夹角。沿轴俯视，若由轴逆时针旋转而成则为正，反之为负。 速度&amp;弹体坐标系： 攻角 ()：飞行器的速度矢量在弹体纵向对称面的投影与Ox1轴之间的夹角。若Ox1轴位于速度投影线的上方，则为正，反之为负。 侧滑角 ()：飞行器速度矢量与纵向对称面之间的夹角。沿飞行方向观察，若来流从右侧流向飞行器，则为正，反之为负。 坐标系变换 主要涉及刚体运动相关内容，通过 旋转矩阵、投影、欧拉角、四元数描述。 旋转矩阵 投影 欧拉角 四元数 Create a quaternion array - MATLAB (mathworks.com)"},{"title":"【笔记】项目管理的逻辑","date":"2022-08-22T00:52:57.000Z","url":"/Project-Management/pro-mgt-lecs.html","tags":[["项目管理","/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"]],"categories":[["Project-Management","/categories/Project-Management/"]],"content":"本笔记主要记录清华大学管理学系列讲座相关笔记。 什么是项目 项目与运营：团队的两大任务 运营(Operation)：持续性、重复性的工作，如报税、报销、记账等 项目(Project)：阶段性，一次性的工作 项目是为创造独特的产品、服务或成果进行的临时性工作 ——PMBOK 6th 项目的特点 组织项目管理 项目生命周期与应用 项目生命周期主要有以下几种： 预测型 迭代型 增量型 敏捷型 预测型 在做项目前已对项目结果心中有数 结果明确，开发过程成熟 Example 经典瀑布开发模型 每一步需要很完善，很到位 需求分析阶段随便提需求，但开始方案设计后不能再动（项目进行方向不可逆） 迭代型与增量型 迭代型： 项目为一整体，逐版本迭代升级 增量型： 整个项目分为多个部分，逐个交付，每个交付都是完成状态 客户可提前了解工作成果 适应性开发（敏捷开发） Product Backlog: 客户需求池 Sprint: 开发周期 有节奏地，持续性地进行适应性开发。 综合对比 管控项目进度 需求不断变更，时间、物质成本不足：先上线，后迭代？\\(\\implies\\) 运维不便 应当确定合理的项目阶段划分 项目的阶段划分 Example 1. 工程建设 按照专业每个阶段设置关口，及时验收，满足条件才可进入下一阶段 Example 2. 产品设计 主要流程： 需求分析 → 原型设计 → 产品开发 → 验收交付 控制项目质量；发现脱离初衷/难以修正时及时止损 主要看是否实现项目既定目标。 项目的分工 面向项目的管理模式 以矩阵形式为特征： 既有按职能划分的专业部门，也有从专业部门抽调形成的项目团队 竖向划分是专业，职能部门；横向划分是项目团队 项目的相关方 凸显模型 (Salience Model) (蓝色为所具备特征) 取得项目相关方共识 References 【公开课】清华大学：项目管理的逻辑（全6讲）"},{"title":"电路元件的建模","date":"2022-08-17T00:00:00.000Z","url":"/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/Modeling-electric-components.html","tags":[["circuit-analysis","/tags/circuit-analysis/"]],"categories":[["电路分析","/categories/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"]],"content":"既然自控那篇文章用到了点 那就整上来( •̀ ω •́ )✧ ## 电路元件的建模 电阻 线性电阻 对于线性定常电阻，，线性时变则非。 非线性电阻 非线性电阻元件的阻值有两种表示方法：静态电阻(总&gt;0)，动态电阻 电压/电流源 电容 约束方程 电容的电压不会跳变 电感 电感的电流不会跳变"},{"title":"(01)数据分析与建模","date":"2022-07-08T00:05:49.000Z","url":"/financial-analysis/analyzing-and-modeling.html","tags":[["finance","/tags/finance/"]],"categories":[["financial-analysis","/categories/financial-analysis/"]],"content":"使用dataset：上证 2008.1.2~2022.7.5 每日收盘指数，详见github repo data/indx.csv 让直方图“连续”起来：直方图与核密度估计 直方图是密度的一个相当粗糙的估计量，它的外观对单元格的数目和位置都是敏感的，x,y轴的变动会显著影响其观感（像个渣男, 做出点小小的改变就欺骗了你的感性）。因此引入核密度估计量让它更像一个概率密度函数，本质上是在一个数据点上给前后的数据以不同权重，形成相对平滑的曲线（感性上可认为与卷积略有相似）。基于 dataset 的核密度估计量可以写作： 其中K一般是标准正态密度函数即其中，b被称为带宽，决定了估计量的分辨率。 核密度估计作图还算简单，可使用sklearn自带函数KernelDensity()： 除此之外，此 法术 函数还有前后摇： fit(X[, y, sample_weight]) Fit the Kernel Density model on the data. get_params([deep]) Get parameters for this estimator. sample([n_samples, random_state]) Generate random samples from the model. score(X[, y]) Compute the total log-likelihood under the model. score_samples(X) Compute the log-likelihood of each sample under the model. set_params(**params) Set the parameters of this estimator. b的影响：下图是b在不同值下所得结果，可见b的值与拟合的敏感度是正相关的，过大的b会造成过拟合，而过小的b会造成欠拟合 凑成正态分布的n种方法"},{"title":"【目录】Sablin的金融玩具箱","date":"2022-05-02T19:23:14.000Z","url":"/Finance/finance-toybox.html","tags":[["python","/tags/python/"],["finance","/tags/finance/"]],"categories":[["Finance","/categories/Finance/"]],"content":" 投资是一种比较花钱的个人爱好。 --Anastasia. Sablina (🤔) 简介： 本系列源自ECE废柴Anastasia-Sablina，绝大部分内容只能保证跑起来[毕竟绝大多数功能都是调用别人的库] ( ´ω` ) . 实际上本系列会更接近技术分析(指不能学大基金广撒网) 本系列代码与跑着玩的数据集存于github repo，参考书目存于同一仓库的reference branch. ​ 在本系列中有概率使用的库有：numpy, pandas, matplotlib, Scikit-Learn, skorch, PyTorch, TA-Lib (链接为官方文档) ​ 随缘更，咱看到哪写到哪，在评论区里骂轻点 🙏🏼 基础设施篇： 醒醒，你亏烂了了：使用飞书机器人通知盯盘情况 被数据淹没，不知所措：搭建一个(暂时)够用的数据库 接受策略（和自己）就是废物的事实：做个用历史数据模拟交易的接口 金融知识篇： 即使没有收益，不妨也来看看什么是收益 学学常用的技术分析指标，以便日后亏得更明白 (毫无实际意义的)实践篇 不知天命，但是可以识时务：道氏理论的程序实践 听话，让我看看：通过回归分析进行公司评级 RICEQUANT（目前使用，但学生license过期就寄了） 证券宝 Tushare pytdx（部分数据有数量级问题） References 对不住我的教授们了 但我是真不想再写APA citation了呜呜呜（＞人＜；） Python for Data Analysis: DATA WRANGLING WITH PANDAS, NUMPY, AND IPYTHON Successful Arithmetic Trading 金融统计与数据分析, David Ruppert 打开量化投资的黑箱(原书第二版), Rishi K. Narang 经典技术分析(原书第三版), Charles. D. Kirkpatrick. Ⅱ"}]